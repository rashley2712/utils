#!/usr/bin/env python
import sys
import commandModule
import astropy.io.fits
import argparse
import photometryClasses
import generalUtils
import photmantoPlotting
import json, numpy

slots = photometryClasses.slotCollection()
state = {	'plotter'	: 'matplot', \
			'overplot'	: False, \
			'plotlimits': 'auto', \
			'plotcolour': 'r', \
		 	'plotterhandle': None}

def loadFromFITSFile(filename, maxRows=0):
	""" Loads photometry data from a FITS file generated by ulog2fits. If maxRows!=0 then it loads up to maxRows."""
	inputFile = astropy.io.fits.open(filename)
	#fileInfo = inputFile.info()
	
	CCD = 'CCD 1'
	
	headerBlock = str(inputFile[0].header)
	
	# Get some header info
	targetName = generalUtils.getKeyValueFromFITSHeader('target', headerBlock)
	filterName = generalUtils.getKeyValueFromFITSHeader('filter', headerBlock)
	runName = generalUtils.getKeyValueFromFITSHeader('Data file name', headerBlock, terminator=' ')
	headers = inputFile[CCD].header
	
	data = inputFile[CCD].data
	columns = inputFile[CCD].columns
	
	allData = []
	
	for index, item in enumerate(data):
		allData.append(item)
		if maxRows!=0 and index>=maxRows-1: break
	
	inputFile.close()
	rows = len(allData)
	# sys.stdout.write("\rRead %d lines with the following columns, %s\n"%(rows, str(columns.names)))
	# sys.stdout.flush()
	
	# Count the number of apertures in this data (using this method, the max is 9!)
	maxApertureIndex = 0
	for column in columns.names:
		try:
			apertureIndex = int(column[-1])
		except ValueError:
			apertureIndex = 0
		if apertureIndex > maxApertureIndex:
			maxApertureIndex = apertureIndex
	# print "This data file has %d apertures."%(maxApertureIndex)
	
	MJDIndex = columns.names.index('MJD')
	for aperture in range(1, maxApertureIndex+1):
		print "Processing aperture data:", aperture
		"""photometry = photometryClasses.photometryObject()
		photometry.times = MJD
		photometry.timeDescription = 'MJD'
		photometry.addValueDescription('MJD')
		exposureIndex = columns.names.index('Expose')
		photometry.addValueDescription('Expose')
		FWHMIndex = columns.names.index('FWHM')
		photometry.addValueDescription('FWHM')
		betaIndex = columns.names.index('beta')
		photometry.addValueDescription('beta')
		xIndex = columns.names.index('X_'+str(aperture))
		photometry.addValueDescription('X')
		yIndex = columns.names.index('Y_'+str(aperture))
		photometry.addValueDescription('Y')
		countsIndex = columns.names.index('Counts_' + str(aperture))
		photometry.addValueDescription('Counts')
		countsErrorIndex = columns.names.index('Sigma_' + str(aperture))
		photometry.addValueDescription('Sigma')
		skyCountsIndex = columns.names.index('Sky_' + str(aperture))
		photometry.addValueDescription('Sky')
		errorFlagIndex = columns.names.index('Eflag_' + str(aperture))
		photometry.addValueDescription('ErrorFlag')
		
		measurementArray = [(data[MJDIndex], data[exposureIndex], data[FWHMIndex], data[betaIndex], \
		                     data[xIndex], data[yIndex], data[countsIndex], data[countsErrorIndex],  \
							 data[skyCountsIndex], int(data[errorFlagIndex])) for data in allData]
		"""
		
		""" Try a different approach to loading this stuff """
		photometry = {}
		photometry['MJD'] = 		data.field('MJD')
		photometry['exposure'] = 	data.field('Expose')
		photometry['FWHM'] = 		data.field('FWHM')
		photometry['beta'] = 		data.field('beta')
		photometry['x'] = 			data.field('X_' + str(aperture))
		photometry['y'] = 			data.field('Y_' + str(aperture))
		photometry['counts'] = 	data.field('Counts_' + str(aperture))
		photometry['sigma'] = 		data.field('Sigma_' + str(aperture))
		photometry['sky'] = 		data.field('Sky_' + str(aperture))
		photometry['sigma'] = 		data.field('Sigma_' + str(aperture))
		photometry['error'] = 		data.field('Eflag_' + str(aperture))
		
		slot = photometryClasses.slotObject()
		slot.channels = ['ULTRASPEC']
		slot.target = targetName
		slot.filter = filterName
		slot.aperture = aperture
		slot.headers = headerBlock
		slot.runName = runName
		slot.setPhotometry(photometry)
		slot.setTimeColumn('MJD')
		numSlots = slots.addSlot(slot)
		# print "Added the data to a new slot. Total number of slots is now: %d"%(numSlots)
		print slot
		
	return

def listAllSlots(options):
	slotInfo = slots.getSlotInfo()
	print slotInfo
	return
	
def plot(slotnumber):
	global state, slot
	
	slot = slots.getSlot(slotnumber)
	if (state['plotter'] == 'pgplot'):
		state = photmantoPlotting.pgplot(slot, plotterHandle)
	else:
		state = photmantoPlotting.matplot(slot, state)
	return 
	
def showState():
	print "Current state variables:"
	print state
	return
	
def setState(variable, value):
	state[variable] = value
	if value == 'on':
		state[variable] = True
	if value == 'off':
		state[variable] = False
	print "New state value: %s = %s "%(variable, value)
	return
	
def saveSession(filename):
	if filename==None or filename=="":
		sessionFilename = 'session.ptm'
		dataFilename = 'data.ptm'
	else:
		sessionFilename+= '.session.ptm'
		dataFilename+= '.data.ptm'
		
	print "Saving session to file:", sessionFilename
	outputfile = open(sessionFilename, "w")
	json.dump(state, outputfile)
	outputfile.close()
	
	print "Saving slots to file:", dataFilename
	outputfile = open(dataFilename, "w")
	
	slotData = []
	for s in slots.slotList:
		dataObject =  s.toJSON()
		slotData.append(dataObject)
	json.dump(slotData, outputfile)
	outputfile.close()
	
	return

def saveSession(filename):
	if filename==None or filename=="":
		sessionFilename = 'session.ptm'
		dataFilename = 'data.ptm'
	else:
		sessionFilename+= '.session.ptm'
		dataFilename+= '.data.ptm'
		
	print "Saving session to file:", sessionFilename
	outputfile = open(sessionFilename, "w")
	json.dump(state, outputfile)
	outputfile.close()
	
	print "Saving slots to file:", dataFilename
	outputfile = open(dataFilename, "w")
	
	slotData = []
	for s in slots.slotList:
		dataObject =  s.toJSON()
		slotData.append(dataObject)
	json.dump(slotData, outputfile)
	outputfile.close()
	
	return
	


		
if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='General purpose tools for loading, manipulating and plotting ULTRACAM and ULTRASPEC photometry data.')
	parser.add_argument('script', type=str, nargs='?', help='The name of a script file containing commands to execute.')
	arg = parser.parse_args()
	# print arg
	
	commands = commandModule.photCommands
	
	if arg.script != None:
		input = open(arg.script, 'rt')
		print "Running the commands found in :", arg.script
		try:
			commands(stdin=input).cmdloop()
		finally:
			input.close()
	
	commands.prompt = 'photmanto> '
	commands.use_rawinput = True
	commands().cmdloop()

	sys.exit()
